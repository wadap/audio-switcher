<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Audio Switcher Mini Bar</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      user-select: none;
    }

    :root {
      --bg-primary: #0a0a0a;
      --bg-tertiary: #1a1a1a;
      --border: #2a2a2a;
      --text-primary: #ffffff;
      --text-muted: #555555;
      --accent: #ff6b35;
      --accent-dim: #ff6b3520;
    }

    body {
      font-family: 'Segoe UI', sans-serif;
      background: transparent;
      overflow: hidden;
    }

    .mini-bar {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 2px;
      padding: 6px 8px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      -webkit-app-region: drag;
    }

    .mini-device {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      border: 1px solid transparent;
      cursor: pointer;
      transition: all 0.15s ease;
      -webkit-app-region: no-drag;
      position: relative;
    }

    .mini-device:hover {
      background: var(--bg-tertiary);
    }

    .mini-device.active {
      background: var(--accent-dim);
      border-color: var(--accent);
    }

    .mini-device svg {
      width: 16px;
      height: 16px;
      fill: var(--text-muted);
    }

    .mini-device.active svg {
      fill: var(--accent);
    }

    .mini-device:hover svg {
      fill: var(--text-primary);
    }

    .mini-device.active:hover svg {
      fill: var(--accent);
    }

    /* Switching animation */
    .mini-device.switching {
      animation: mini-pulse 0.3s ease;
    }

    @keyframes mini-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(0.9); }
    }
  </style>
</head>
<body>
  <div class="mini-bar" id="miniBar"></div>

  <script>
    const { ipcRenderer } = require('electron');

    const miniBar = document.getElementById('miniBar');

    let devices = [];
    let allDevices = [];
    let enabledDevices = null;

    function getDeviceIcon(name) {
      if (/headset|ヘッドセット/i.test(name)) {
        return '<path d="M4 11C4 5.48 7.58 2 12 2s8 3.48 8 9h-2c0-3.31-2.69-6-6-6s-6 2.69-6 6H4z"/><rect x="1" y="11" width="5" height="9" rx="2"/><rect x="18" y="11" width="5" height="9" rx="2"/><path d="M3 18v3c0 1.66 1.34 3 3 3h5v-2H6c-.55 0-1-.45-1-1v-3H3z"/>';
      }
      if (/headphone|kopfh|ヘッドホン|ヘッドフォン|イヤホン|イヤフォン/i.test(name)) {
        return '<path d="M4 11C4 5.48 7.58 2 12 2s8 3.48 8 9h-2c0-3.31-2.69-6-6-6s-6 2.69-6 6H4z"/><rect x="1" y="11" width="5" height="9" rx="2"/><rect x="18" y="11" width="5" height="9" rx="2"/>';
      }
      if (/hdmi|display|monitor|tv|tele|モニター|テレビ/i.test(name)) {
        return '<path d="M21 2H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h7v2H8v2h8v-2h-2v-2h7c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H3V4h18v12z"/>';
      }
      if (/digital|spdif|optical|toslink|デジタル|光/i.test(name)) {
        return '<circle cx="12" cy="12" r="3"/><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"/><path d="M12 6c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm0 10c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"/>';
      }
      if (/bluetooth|bt /i.test(name)) {
        return '<path d="M17.71 7.71L12 2h-1v7.59L6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 11 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM13 5.83l1.88 1.88L13 9.59V5.83zm1.88 10.46L13 18.17v-3.76l1.88 1.88z"/>';
      }
      return '<path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>';
    }

    function parseDeviceName(name) {
      const match = name.match(/^(.+?)\s*\((.+)\)\s*$/);
      if (match) {
        const type = match[1].trim();
        let hardware = match[2].trim()
          .replace(/High Definition Audio$/i, '')
          .replace(/Audio$/i, '')
          .trim();
        return { type, hardware: hardware || match[2].trim() };
      }
      return {
        type: name.replace(/High Definition Audio Device/gi, '').replace(/Audio Device/gi, '').trim(),
        hardware: ''
      };
    }

    async function loadDevices() {
      try {
        const [result, savedEnabledDevices] = await Promise.all([
          ipcRenderer.invoke('get-audio-devices'),
          ipcRenderer.invoke('get-enabled-devices')
        ]);

        if (result.error) return;

        allDevices = result.devices;
        enabledDevices = savedEnabledDevices;

        if (enabledDevices === null) {
          devices = allDevices;
        } else {
          devices = allDevices.filter(d => enabledDevices.includes(d.id));
        }

        devices.sort((a, b) => {
          const nameA = parseDeviceName(a.name).type.toLowerCase();
          const nameB = parseDeviceName(b.name).type.toLowerCase();
          return nameA.localeCompare(nameB);
        });

        renderDevices();
      } catch (error) {
        console.error('Failed to load devices:', error);
      }
    }

    function renderDevices() {
      miniBar.innerHTML = devices.map((device, index) => {
        const icon = getDeviceIcon(device.name);
        return `
          <div class="mini-device ${device.isDefault ? 'active' : ''}"
               data-id="${device.id}"
               data-index="${index}">
            <svg viewBox="0 0 24 24">${icon}</svg>
          </div>
        `;
      }).join('');

      document.querySelectorAll('.mini-device').forEach((item, i) => {
        item.addEventListener('click', () => switchDevice(item.dataset.id, i));

        item.addEventListener('mouseenter', () => {
          const parsed = parseDeviceName(devices[i].name);
          const rect = item.getBoundingClientRect();
          ipcRenderer.send('mini-bar-tooltip-show', {
            name: parsed.type,
            detail: parsed.hardware || 'Playback Device',
            elementRect: { x: rect.left, y: rect.top, width: rect.width, height: rect.height }
          });
        });

        item.addEventListener('mouseleave', () => {
          ipcRenderer.send('mini-bar-tooltip-hide');
        });
      });

      // Resize the window to fit content
      requestAnimationFrame(() => {
        let width = 16 + 2; // padding 8px * 2 + border 2px
        const items = miniBar.querySelectorAll('.mini-device');
        items.forEach((item, i) => {
          width += item.offsetWidth;
          if (i < items.length - 1) width += 2; // gap
        });
        const height = 28 + 12 + 2; // 28px icon + 6px*2 padding + 2px border
        ipcRenderer.send('mini-bar-resize', Math.ceil(width), height);
      });
    }

    async function switchDevice(deviceId, index) {
      const items = document.querySelectorAll('.mini-device');
      const targetItem = items[index];

      if (targetItem.classList.contains('active')) return;

      targetItem.classList.add('switching');

      try {
        const result = await ipcRenderer.invoke('set-audio-device', deviceId);
        if (result.success) {
          items.forEach(item => item.classList.remove('active'));
          targetItem.classList.add('active');
          devices.forEach(d => d.isDefault = false);
          devices[index].isDefault = true;
        }
      } catch (error) {
        console.error('Failed to switch device:', error);
      }

      setTimeout(() => targetItem.classList.remove('switching'), 300);
    }

    // Hover opacity
    const container = document.querySelector('.mini-bar');
    container.addEventListener('mouseenter', () => {
      ipcRenderer.send('mini-bar-hover', true);
    });
    container.addEventListener('mouseleave', () => {
      ipcRenderer.send('mini-bar-hover', false);
    });

    // Right-click context menu
    document.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      ipcRenderer.send('mini-bar-context-menu');
    });

    // Refresh from main process
    ipcRenderer.on('refresh-devices', () => {
      loadDevices();
    });

    // Auto-refresh on visibility
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) loadDevices();
    });

    // Init
    loadDevices();
  </script>
</body>
</html>
